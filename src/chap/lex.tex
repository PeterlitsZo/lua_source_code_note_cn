
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Lex 分词}

运行一个解释器编程语言，我们一般会使用\cmd{lex}来对程序进行分词，而使用\cmd{yyac}%
来对标记流（\cmd{lex}分完词之后的结果）生成抽象语法树。

在分析之前，我们先在\cmd{lua.c}中根据\cmd{main}函数来看看它如何解析命令行参数。


\section{命令行解析}

我们在了解如何分词之前我们需要了解它到底在什么时候开始分词的。在一开始我们跟着
调用顺序从\cmd{main}入手，随后是\cmd{pmain}，等等，如示意图\ref{lex.tex[0]}。

\begin{code}{lex.tex[0]}{示意图：从\cmd{main}到\cmd{lex}}
main
 +- 加载全局状态机
 +- 运行 cfunction: pmain
 |   +- 解析命令行参数
 |   +- 如果是有其他情况...
 |   +- 如果是 -i 或者无参数运行：
 |       +- 运行 doREPL，进入循环。
 |           +- 使用 loadline 来读取输入
 |           +- 使用 docall 来进行运行。
 +- 结束状态机运行
\end{code}


\subsection{\cmd{main}入口}

我们可以看到如代码\ref{lua.c::main}所示一样，

\begin{ccode}{lua.c::main}{\cmd{lua.c}中的\cmd{main}函数}
int main (int argc, char **argv) {
  int status, result;
  lua_State *L = luaL_newstate();  /* create state */
  if (L == NULL) {
    l_message(argv[0], "cannot create state: not enough memory");
    return EXIT_FAILURE;
  }
  lua_pushcfunction(L, &pmain);  /* to call 'pmain' in protected mode */
  lua_pushinteger(L, argc);  /* 1st argument */
  lua_pushlightuserdata(L, argv); /* 2nd argument */
  status = lua_pcall(L, 2, 1, 0);  /* do the call */
  result = lua_toboolean(L, -1);  /* get result */
  report(L, status);
  lua_close(L);
  return (result && status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;
}
\end{ccode}

我们首先创建了一个\cmd{lua\_state*}对象来存储\cmd{VM}\footnote{\cmd{VM}，可以说是
程序虚拟机的意思。}的状态。

之后我们将临时函数（这里是\cmd{pmain}）和命令行变量入栈调用（参数是\cmd{2}和\cmd
{1}，然后使用\cmd{pmain}对齐调用），最后退出。

我们接下来看看类型为\cmd{cfunction}的函数指针的调用顺序。


\subsection{\cmd{pmain}函数}

如代码\ref{lua.c::pmain}所示，我们看到了类型为\cmd{cfunction}的函数\cmd{pmain}，
其接受一个状态\cmd{lua\_State*}，然后返回一个\cmd{int}。

\begin{ccode}{lua.c::pmain}{\cmd{lua.c}中的\cmd{pmain}函数}
/*
** Main body of stand-alone interpreter (to be called in protected mode).
** Reads the options and handles them all.
*/
static int pmain (lua_State *L) {
  int argc = (int)lua_tointeger(L, 1);
  char **argv = (char **)lua_touserdata(L, 2);
  int script;
  int args = collectargs(argv, &script);
  luaL_checkversion(L);  /* check that interpreter has correct version */
  if (argv[0] && argv[0][0]) progname = argv[0];
  if (args == has_error) {  /* bad arg? */
    print_usage(argv[script]);  /* 'script' has index of bad arg. */
    return 0;
  }
  if (args & has_v)  /* option '-v'? */
    print_version();
  if (args & has_E) {  /* option '-E'? */
    lua_pushboolean(L, 1);  /* signal for libraries to ignore env. vars. */
    lua_setfield(L, LUA_REGISTRYINDEX, "LUA_NOENV");
  }
  luaL_openlibs(L);  /* open standard libraries */
  createargtable(L, argv, argc, script);  /* create table 'arg' */
  lua_gc(L, LUA_GCGEN, 0, 0);  /* GC in generational mode */
  if (!(args & has_E)) {  /* no option '-E'? */
    if (handle_luainit(L) != LUA_OK)  /* run LUA_INIT */
      return 0;  /* error running LUA_INIT */
  }
  if (!runargs(L, argv, script))  /* execute arguments -e and -l */
    return 0;  /* something failed */
  if (script < argc &&  /* execute main script (if there is one) */
      handle_script(L, argv + script) != LUA_OK)
    return 0;
  if (args & has_i)  /* -i option? */
    doREPL(L);  /* do read-eval-print loop */
  else if (script == argc && !(args & (has_e | has_v))) {  /* no arguments? */
    if (lua_stdin_is_tty()) {  /* running in interactive mode? */
      print_version();
      doREPL(L);  /* do read-eval-print loop */
    }
    else dofile(L, NULL);  /* executes stdin as a file */
  }
  lua_pushboolean(L, 1);  /* signal no errors */
  return 1;
}
\end{ccode}

我们在其中的函数片段\ref{lua.c::pmain[0]}可以看到，我们如果使用\cmd{-i}或者无参
数输入的时候，就会触发交互式，即\cmd{doREFL}。我们会认为从这里作为突破口，会是一
个有效的方法。

\begin{ccode}{lua.c::pmain[0]}{\cmd{lua.c}中的\cmd{pmain}函数，关于交互式的片段}
  if (args & has_i)  /* -i option? */
    doREPL(L);  /* do read-eval-print loop */
  else if (script == argc && !(args & (has_e | has_v))) {  /* no arguments? */
    if (lua_stdin_is_tty()) {  /* running in interactive mode? */
      print_version();
      doREPL(L);  /* do read-eval-print loop */
    }
    else dofile(L, NULL);  /* executes stdin as a file */
  }
\end{ccode}

接下来是下一个部分，即\cmd{REPL}中最重要的部分。


\subsection{\cmd{doREPL}函数}

我们看到代码\ref{lua.c::doREPL}，它就和注释一样：读取，求值，输出，循环。我们注
意到，在循环的过程中，最主要的是我们使用的函数\cmd{loadline}和\cmd{docall}。

因为我们只关注如何从交互式开始进行分词，所以说我们只会研究\cmd{loadline}的运行方
式。

\begin{ccode}{lua.c::doREPL}{\cmd{lua.c}中的\cmd{doREPL}函数}
/*
** Do the REPL: repeatedly read (load) a line, evaluate (call) it, and
** print any results.
*/
static void doREPL (lua_State *L) {
  int status;
  const char *oldprogname = progname;
  progname = NULL;  /* no 'progname' on errors in interactive mode */
  lua_initreadline(L);
  while ((status = loadline(L)) != -1) {
    if (status == LUA_OK)
      status = docall(L, 0, LUA_MULTRET);
    if (status == LUA_OK) l_print(L);
    else report(L, status);
  }
  lua_settop(L, 0);  /* clear stack */
  lua_writeline();
  progname = oldprogname;
}
\end{ccode}

接下来我们会寻找在交互式中，\cmd{lua}如何将输入转换为\cmd{lua}本身能够运行的语法
结构，即\cmd{loadline}函数。


\subsection{\cmd{loadline}函数和进入解析的入口\cmd{pushline}}

如代码\ref{lua.c::loadline}所示，我们首先会使用\cmd{pushline}来输入解析。

[TODO]: 此处代码有误。

\begin{ccode}{lua.c::loadline}{\cmd{lua.c}中的\cmd{loadline}函数}
/*
** read a line and try to load (compile) it first as an expression (by
** adding "return " in front of it) and second as a statement. return
** the final status of load/call with the resulting function (if any)
** in the top of the stack.
*/
static int loadline (lua_state *l) {
  int status;
  lua_settop(l, 0);
  if (!pushline(l, 1))
    return -1;  /* no input */
  if ((status = addreturn(l)) != lua_ok)  /* 'return ...' did not work? */
    status = multiline(l);  /* try as command, maybe with continuation lines */
  lua_remove(l, 1);  /* remove line from the stack */
  lua_assert(lua_gettop(l) == 1);
  return status;
}
\end{ccode}

而\cmd{pushline}，如代码\ref{lua.c::pushline}所示，我们

\begin{ccode}{lua.c::pushline}{\cmd{lua.c}中\cmd{REPL}的IO动作与语法解析}
/*
** Prompt the user, read a line, and push it into the Lua stack.
*/
static int pushline (lua_State *L, int firstline) {
  char buffer[LUA_MAXINPUT];
  char *b = buffer;
  size_t l;
  const char *prmt = get_prompt(L, firstline);
  int readstatus = lua_readline(L, b, prmt);
  if (readstatus == 0)
    return 0;  /* no input (prompt will be popped by caller) */
  lua_pop(L, 1);  /* remove prompt */
  l = strlen(b);
  if (l > 0 && b[l-1] == '\n')  /* line ends with newline? */
    b[--l] = '\0';  /* remove it */
  if (firstline && b[0] == '=')  /* for compatibility with 5.2, ... */
    lua_pushfstring(L, "return %s", b + 1);  /* change '=' to 'return' */
  else
    lua_pushlstring(L, b, l);
  lua_freeline(L, b);
  return 1;
}
\end{ccode}


